#!/bin/bash

BASE=$PWD
NONO=$BASE/nono

############## package storage ################################

entry_exists() {
  [[ ! -e $PKGS ]] && \
    return 1

  return $(grep -q "$1" $PKGS)
}

add_entry() {
  [[ ! -e $PKGS ]] && \
    return 1

  echo "$1" >> $PKGS
  return 0
}

#

####### log ##########

die() {
  echo "$@"
  exit 1
}

####### utils ##########

read_setting() {
  if [[ ! -e $2 ]]; then
    echo ""
    return
  fi

  line=$(grep "${1}=" $2)

  if [[ ${line::1} == "#" ]]; then
    echo ""
    return
  fi

  echo ${line#*=}
}

array_contains() {
    local seeking=$1; shift
    local in=1
    for element; do
        if [[ $element == "$seeking" ]]; then
            in=0
            break
        fi
    done
    return $in
}

fn_exists() {
  if type $1 2>/dev/null | grep -q 'function'; then
    return 0
  fi

  return 1
}

########### preparation ##############

# needed when installing something
config() {
  [[ -z $ROOT ]] && \
    ROOT=$(dirname $PWD)

  [[ -d $ROOT/pkg ]] || \
    die "invalid root"

  [[ -z $INSTALL ]] && \
    INSTALL=$ROOT

  PKGDIR=$ROOT/pkg
  PKGS=$ROOT/pkgs

  SRC=$ROOT/src
  BUILD=$SRC/build
  DL=$SRC/dl

  if [[ -e $BASE/config ]]; then
    . $BASE/config
  elif [[ -e $SRC/config ]]; then
    . $SRC/config
  fi

  [[ -z $CC ]] && CC=gcc

  [[ -e /bin/$CC ]] || \
    die "missing compiler: $CC"

  HOSTCC=$CC

  export PREFIX
}

config_build() {
  local preffered=$(nproc)
  local max=$(($preffered+1))

  if [[ -z $JOBS ]] || (($JOBS > $max)); then
    JOBS=$preffered
  fi

  ARCH=x86_64
  TARGET=$ARCH-linux-musl
  HOST=$($CC -dumpmachine)

  CONFIGURE="./configure --prefix=$PREFIX"
  MAKE="make -j$JOBS"
  INSTALL="$MAKE DESTDIR=$ROOT install"

  BIN_PREFIX=$PREFIX/bin
  BIN=$ROOT$BIN_PREFIX

  ETC_PREFIX=$PREFIX/etc
  ETC=$ROOT$ETC_PREFIX

  INCLUDE_PREFIX=$PREFIX/include
  INCLUDE=$ROOT$INCLUDE_PREFIX

  LIB_PREFIX=$PREFIX/lib
  LIB=$ROOT$LIB_PREFIX

  SHARE_PREFIX=$PREFIX/share
  SHARE=$ROOT$LIB_PREFIX

  MAN_PREFIX=$SHARE_PREFIX/man
  MAN=$ROOT$MAN_PREFIX

  CFLAGS="-fno-unwind-tables -fno-asynchronous-unwind-tables -Wa,--noexecstack -fno-math-errno"
  LDFLAGS="-Wl,-z,relro,-z,now -Wl,-z,text"
}

config_pkg() {
  local pkg=$1

  local file=$(read_recipe $pkg)

  local settings=(STATIC OPT SECURE)

  for setting in ${settings[@]}; do
    unset $setting
  done

  for setting in ${settings[@]}; do
    local value=$(read_setting $setting $file)

    if [[ -z $value ]]; then
      continue
    fi

    eval local $setting=$value
  done

  [[ -z $OPT ]] && OPT=yes
  [[ -z $SECURE ]] && SECURE=yes

  if [[ $OPT = yes ]]; then
    CFLAGS="$CFLAGS -O3 -fstrength-reduce -fthread-jumps -fcse-follow-jumps -fcse-skip-blocks -frerun-cse-after-loop -fexpensive-optimizations -fforce-addr -fomit-frame-pointer"
  else
    CFLAGS="$CFLAGS -Os -g0 -fdata-sections -ffunction-sections"
    LDFLAGS="$LDFLAGS -Wl,--gc-sections"
  fi

  if [[ $SECURE = yes ]]; then
    CFLAGS="$CFLAGS -fPIE -fstack-protector"
    LDFLAGS="$LDFLAGS -fpie"
  fi

  if [[ $STATIC = yes ]]; then
    LDFLAGS="$LDFLAGS -static"
  fi

  unset OPT SECURE
  export CFLAGS LDFLAGS
}

# used for packages, not groups
read_recipe() {
  local pkg=$1

  local pkgdir=$ROOT/pkg/$pkg

  local small

  [[ -e $pkgdir ]] && \
    small=yes

  [[ -d $pkgdir ]] && \
    small=no

  [[ -z $small ]] && \
    echo "" && return

  if [[ $small = yes ]]; then
    echo $pkgdir
  else
    echo $pkgdir/build
  fi
}

################### Group handling #################

# example:

# base:
# option=USERLAND
# options=(base-suckless base-busybox)

# set_option base busybox -> USERLAND=busybox
# get_option base -> USERLAND

# get_option_value base -> busybox
# get_choose: get_option_value with checks

# notes:
# default option is first
# only group (main) will be count as installed
# 'config' file can override options (USERLAND), else it will be asked, if timeout, default

#############################################

is_group() {
  [[ -z $(read_setting options $(read_recipe $1)) ]] && return 1 || return 0
}

is_option() {
  return $(is_group $(read_setting group $(read_recipe $1)))
}

option_set() {
  [[ -z $(get_option_value $1) ]] && return 1 || return 0
}

get_option_value() {
  local option=$(get_option $1)

  echo "${!option}"
}

get_option() {
  echo $(read_setting option $ROOT/pkg/$1)
}

set_option() {
  local option=$(get_option $1)
  local choose=$2

  [[ -z $option ]] || [[ -z $choose ]] && return 1

  eval $option=$choose

  return 0
}

get_choose() {
  local name=$1

  if is_group $name; then
    . $ROOT/pkg/$name

    if [[ -z $options ]]; then
      echo ""
      return
    fi

    local choose=$(get_option_value $name)

    # default
    if [[ -z $choose ]]; then
      temp=$options
      set -- $temp
      choose=$1
    fi

    if array_contains $choose ${options[@]}; then
      echo $choose
    else
      echo ""
    fi
  fi
}

############# packages ##########

pkg_exists() {
  [[ -z $(read_recipe $1) ]] && return 1 || return 0
}

pkg_installed() {
  local pkg=$1

  if ! pkg_exists $pkg; then
    return 1
  fi

  if is_group $pkg; then
    . $ROOT/pkg/$pkg

    for option in ${options[@]}; do
      if entry_exists $option; then
        echo $option
        return 0
      fi
    done
  else
    return $(entry_exists $pkg)
  fi

  return 1
}

install_pkg() {
  local pkgs=()

  for pkg in $@; do
    if ! array_contains $pkg ${pkgs[@]}; then
      pkgs+=($pkg)
    fi
  done

  config

  local list=()

  for pkg in ${pkgs[@]}; do
    local file=$(read_recipe $pkg)

    if [[ -z $file ]]; then
      echo "package $pkg doesnt exist"
      continue
    fi

    list+=($pkg)
  done

  config_build

  local error=no

  for pkg in ${list[@]}; do
    if ! pkg_install $pkg; then
      error=yes
    fi
  done

  [[ $error = yes ]] && return 1 || return 0
}

ask_options() {
  local pkg=$1
  return
  echo "choose options for: $pkg"
  echo "todo"
  #set_option $pkg base-suckless
}

pkg_install() {
  local pkg=$1

  if is_group $pkg; then
    local name=$(pkg_installed $pkg)

    if [[ ! -z $name ]]; then
      echo "group $pkg is installed as $name"
      return 0
    fi

    if ! option_set $pkg && [[ ! -z $(read_setting option $file) ]]; then
      ask_options $pkg
    fi

    local choose=$(get_choose $pkg)

    if [[ -z $choose ]]; then
      echo "option is set wrong: $pkg"
      return 1
    fi

    if ! pkg_exists $choose; then
      echo "option $choose package doesnt exist: $pkg"
      return 1
    fi

    if pkg_install $choose; then
      add_entry $choose
      return 0
    fi

    return 1
  fi

  if pkg_installed $pkg; then
    echo "package $pkg is already installed"
    return 0
  fi

  local file=$(read_recipe $pkg)

  echo "installing: $pkg"

  local small=yes

  if [[ $file == *"build"* ]]; then
    small=no
  fi

  local settings=(ver src deps group files)

  for setting in ${settings[@]}; do
    unset $setting
  done

  for setting in ${settings[@]}; do
    local value=$(read_setting $setting $file)

    if [[ -z $value ]]; then
      continue
    fi

    eval local $setting=$value
  done

  local git=no

  if [[ ! -z $src ]]; then
    local filename=$(basename $src)

    if [[ $src == *"git"* ]] && [[ $filename != *"."* ]]; then
      git=yes
      unset $filename
    fi
  fi

  local pkgtype

  if [[ $git = yes ]]; then
    pkgtype=git
  elif [[ ! -z $src ]]; then
    pkgtype=normal
  elif [[ ! -z $deps ]]; then
    pkgtype=group
  else
    echo "empty package: $pkg"
    return 1
  fi

  if [[ $pkgtype = group ]]; then
    local error=no
  fi

  if [[ ! -z $deps ]]; then
    for dep in ${deps[@]}; do
      if ! pkg_exists $dep; then
        echo "dependency $dep of pkg doesnt exist: $pkg"
        continue
      fi

      if ! pkg_install $dep; then
        echo "dep of pkg $pkg error: $dep"
        error=yes
        break
      fi
    done
  fi

  for setting in ${settings[@]}; do
    unset $setting
  done

  for setting in ${settings[@]}; do
    local value=$(read_setting $setting $file)

    if [[ -z $value ]]; then
      continue
    fi

    eval local $setting=$value
  done

  if [[ $pkgtype = group ]]; then
    [[ $error = yes ]] && return 1 || return 0
  fi

  local name

  if [[ -z $ver ]]; then
    name=$pkg
  else
    name=$pkg-$ver
  fi

  local work=$BUILD/$name

  if [[ $pkgtype = normal ]] || [[ $pkgtype = git ]]; then
    [[ -z $files ]] && [[ $DEBUG != yes ]] && \
      echo "missing files setting" && return 1
  fi

  local pkgdir=$PKGDIR/$pkg

  if [[ $small = no ]]; then
    STUFF=$pkgdir/stuff
  fi

  if [[ ! -d $work ]]; then
    if [[ $git = yes ]]; then
      cd $BUILD

      command="git clone $src $name --recurse-submodules"
    else
      cd $DL

      command="wget --no-check-certificate $src -O $filename"
    fi

    if [[ $SILENT = yes ]]; then
      $command &>/dev/null
    else
      $command
    fi
  fi

  if [[ $pkgtype = normal ]]; then
    if [[ ! -e $DL/$filename ]]; then
      echo "failed to download package: $pkg"
      return 1
    else
      cd $DL

      if [[ $filename != *"zip"* ]]; then
        mkdir -p $work
      fi

      case $filename in
      *.zip) unzip $filename -d $work &>/dev/null ; ;;
      *.tgz|*.gz) tar xzvf $filename -C $work --strip-components 1 &>/dev/null ; ;;
      *.tbz2|*.bz2) tar xjvf $filename -C $work --strip-components 1 &>/dev/null ; ;;
      *.xz) tar xf $filename -C $work --strip-components 1 &>/dev/null ; ;;
      esac
    fi
  fi

  if [[ ! -d $work ]]; then
    if [[ $pkgtype = normal ]]; then
      echo "failed to extract package $pkg"
    else
      echo "failed to clone git repo $pkg"
    fi

    return 1
  fi

  if $(check_installed $work $files); then
    echo "installed missing built package: $pkg"
    return 0
  fi

  config_pkg $pkg

  if [[ -d $pkgdir/files ]]; then
    yes | \cp -rf $pkgdir/files/* $work
  fi

  cd $work

  if [[ -d $pkgdir/patches ]]; then
    for patch in $pkgdir/patches/*; do
      patch -p1 < $patch &>/dev/null
    done
  fi

  . $file

  echo "configuring $pkg"

  if ! fn_exists configure; then
    if [[ -e CMakeLists.txt ]]; then
      mkdir -p build
      cd build

      if [[ $SILENT = yes ]]; then
        cmake .. &>/dev/null
      else
        cmake ..
      fi
    elif [[ -e configure ]]; then
      grep -q '--prefix' configure &>/dev/null

      if [ $? -eq 0 ]; then
        $CONFIGURE
      else
        ./configure
      fi
    fi
  else
    if [[ $SILENT = yes ]]; then
      configure &>/dev/null
    else
      configure
    fi
  fi

  echo "compiling $NAME"

  if ! fn_exists build; then
    local makefile

    if [[ -e Makefile ]]; then
      makefile=Makefile
    fi

    if [[ -e GNUmakefile ]]; then
      makefile=GNUmakefile
    fi

    if [[ -e $makefile ]]; then
      if [[ $SILENT = yes ]]; then
        $MAKE &>/dev/null
      else
        $MAKE
      fi
    else
      die "no build() in package $pkg"
    fi
  else
    if [[ $SILENT = yes ]]; then
      build &>/dev/null
    else
      build
    fi
  fi

  echo "packaging $NAME"

  if ! fn_exists install; then
    local makefile

    if [[ -e Makefile ]]; then
      makefile=Makefile
    fi
    if [[ -e GNUmakefile ]]; then
      makefile=GNUmakefile
    fi

    if [[ -e $makefile ]]; then
      grep -q 'install:' $makefile &>/dev/null

      if [ $? -eq 0 ]; then
        $INSTALL
      fi
    fi
  else
    if [[ $SILENT = yes ]]; then
      install &>/dev/null
    else
      install
    fi
  fi

  if check_installed $work $files; then
    echo "package $pkg installed successfully"
    add_entry $pkg
    return 0
  fi

  if [[ $DEBUG = no ]]; then
    return 1
  fi
}

check_installed() {
  local work=$1
  local files=$2

  if [[ -d $work ]]; then
    cd $work

    for file in "${files[@]}"; do
      [[ -d $file ]] || [[ -e $file ]] && return 0
    done

    cd $BASE
  fi

  return 1
}

remove_pkg() {
  local pkgs=()

  for pkg in $@; do
    if ! array_contains $pkg ${pkgs[@]}; then
      pkgs+=($pkg)
    fi
  done

  config

  local list=()

  for pkg in ${pkgs[@]}; do
    echo $pkg
  done

  #sed -i "/$PKG/d" $PKGS
}

help() {
  echo "todo"
}

run() {
  action=$1 && shift

  case $action in
  -i) install_pkg $@ ; ;;
  -r) remove_pkg $@ ; ;;
  *) help ; ;;
  esac
}

run $@