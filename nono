#!/bin/bash

BASE=$PWD
NONO=$BASE/nono

config_dev() {
  if [[ -e $BASE/config ]]; then
    . $BASE/config
  elif [[ -e $SRC/config ]]; then
    . $SRC/config
  fi

  [[ -z $CC ]] && CC=gcc

  [[ -e /bin/$CC ]] || \
    die "missing compiler: $CC"

  HOSTCC=$CC
}

pkg_open() {
  local pkg=$1

  config

  local pkgdir=$ROOT/pkg/$pkg

  local small

  [[ -e $pkgdir ]] && \
    small=yes

  [[ -d $pkgdir ]] && \
    small=no

  [[ -z $small ]] && \
    die "package $pkg does not exist"

  local pkgfile files patches

  if [[ $small = yes ]]; then
    pkgfile=$PKGDIR
  else
    pkgfile=$PKGDIR/build
    files=$PKGDIR/files
    patches=$PKGDIR/patches

    STUFF=$PKGDIR/stuff
  fi

  . $pkgfile

  if [[ ! -z "$name" ]] && [[ $name != *" "* ]]; then
    name=${name,,}
    PKG=$name
    unset $name
  fi

  local git=no

  if [[ ! -z $src ]]; then
    FILENAME=$(basename $src)

    if [[ $src == *"git"* ]] && [[ $FILENAME != *"."* ]]; then
      git=yes
    fi
  fi

  local pkgtype

  if [[ $git = yes ]]; then
    pkgtype=git
  elif [[ ! -z $src ]]; then
    pkgtype=normal
  elif [[ ! -z $deps ]]; then
    pkgtype=group
  elif [[ ! -z $options ]]; then
    pkgtype=option
  else
    die "empty package: $pkg"
  fi

  if [[ $pkgtype = normal ]] || [[ $pkgtype = git ]]; then
    [[ -z $files ]] && [[ $DEBUG != yes ]] && \
      die "missing files setting"
  fi

  if [[ -z $ver ]]; then
    NAME=$pkg
  else
    NAME=$pkg-$ver
  fi
}

pkg_prepare() {
  local pkg=$1

  pkg_open

  BUILD=$SRC/build

  if [[ $PKGTYPE = normal ]]; then
    DL=$SRC/dl

    FILE=$DL/$FILENAME
    WORK=$BUILD/$NAME
  elif [[ $PKGTYPE = git ]]; then
    WORK=$BUILD/$NAME

    unset $FILENAME
  elif [[ $PKGTYPE = group ]]; then
    unset $ver
  fi

  local preffered=$(nproc)
  local max=$(($preffered+1))

  if [[ -z $JOBS ]] || (($JOBS > $max)); then
    JOBS=$preffered
  fi

  ARCH=x86_64
  TARGET=$ARCH-linux-musl
  HOST=$($CC -dumpmachine)

  CONFIGURE="./configure --prefix=$PREFIX"
  MAKE="make -j$JOBS"
  INSTALL="$MAKE DESTDIR=$ROOT install"

  BIN_PREFIX=$PREFIX/bin
  BIN=$ROOT$BIN_PREFIX

  ETC_PREFIX=$PREFIX/etc
  ETC=$ROOT$ETC_PREFIX

  INCLUDE_PREFIX=$PREFIX/include
  INCLUDE=$ROOT$INCLUDE_PREFIX

  LIB_PREFIX=$PREFIX/lib
  LIB=$ROOT$LIB_PREFIX

  SHARE_PREFIX=$PREFIX/share
  SHARE=$ROOT$LIB_PREFIX

  MAN_PREFIX=$SHARE_PREFIX/man
  MAN=$ROOT$MAN_PREFIX

  CFLAGS="-fno-unwind-tables -fno-asynchronous-unwind-tables -Wa,--noexecstack -fno-math-errno"
  LDFLAGS="-Wl,-z,relro,-z,now -Wl,-z,text"

  [[ -z $OPT ]] && OPT=yes
  [[ -z $SECURE ]] && SECURE=yes

  if [[ $OPT = yes ]]; then
    CFLAGS="$CFLAGS -O3 -fstrength-reduce -fthread-jumps -fcse-follow-jumps -fcse-skip-blocks -frerun-cse-after-loop -fexpensive-optimizations -fforce-addr -fomit-frame-pointer"
  else
    CFLAGS="$CFLAGS -Os -g0 -fdata-sections -ffunction-sections"
    LDFLAGS="$LDFLAGS -Wl,--gc-sections"
  fi

  if [[ $SECURE = yes ]]; then
    CFLAGS="$CFLAGS -fPIE -fstack-protector"
    LDFLAGS="$LDFLAGS -fpie"
  fi

  if [[ $STATIC = yes ]]; then
    LDFLAGS="$LDFLAGS -static"
  fi

  if [[ -z $SILENT ]]; then
    if [[ $DEBUG = yes ]]; then
      SILENT=no
    else
      SILENT=yes
    fi
  fi

  unset $OPT
  unset $SECURE

  export PREFIX
  export CFLAGS LDFLAGS
}

pkg_extract() {
  cd $DL

  if [[ $FILENAME != *"zip"* ]]; then
    mkdir $WORK
  fi

  case $FILENAME in
  *.zip) unzip $FILENAME -d $WORK &>/dev/null ; ;;
  *.tgz|*.gz) tar xzvf $FILENAME -C $WORK --strip-components 1 &>/dev/null ; ;;
  *.tbz2|*.bz2) tar xjvf $FILENAME -C $WORK --strip-components 1 &>/dev/null ; ;;
  *.xz) tar xf $FILENAME -C $WORK --strip-components 1 &>/dev/null ; ;;
  esac
}

pkg_download() {
  info "downloading $PKG"

  if [[ $GIT = yes ]]; then
    cd $BUILD

    command="git clone $src $NAME --recurse-submodules"
  else
    cd $DL

    command="wget --no-check-certificate $src -O $FILENAME"
  fi

  if [[ $SILENT = yes ]]; then
    $command &>/dev/null
  else
    $command
  fi
}

pkg_configure() {
  info "configuring $PKG"

  if ! fn_exists configure; then
    if [[ -e CMakeLists.txt ]]; then
      mkdir -p build
      cd build

      if [[ $SILENT = yes ]]; then
        cmake .. &>/dev/null
      else
        cmake ..
      fi
    elif [[ -e configure ]]; then
      grep -q '--prefix' configure &>/dev/null

      if [ $? -eq 0 ]; then
        $CONFIGURE
      else
        ./configure
      fi
    fi
  else
    if [[ $SILENT = yes ]]; then
      configure &>/dev/null
    else
      configure
    fi
  fi
}

pkg_build() {
  info "compiling $NAME"

  if [[ -d $PATCHES ]]; then
    for patch in $PATCHES/*; do
      patch -p1 < $patch &>/dev/null
    done
  fi

  if ! fn_exists build; then
    if [[ -e Makefile ]]; then
      if [[ $SILENT = yes ]]; then
        $MAKE &>/dev/null
      else
        $MAKE
      fi
    else
      die "no build() in package $PKG"
    fi
  else
    if [[ $SILENT = yes ]]; then
      build &>/dev/null
    else
      build
    fi
  fi

  local error=yes

  for file in "${files[@]}"; do
    [[ -d $file ]] || [[ -e $file ]] && error=no
  done

  [[ $error = yes && $DEBUG != yes ]] && \
    die "build error on $PKG package"
}

pkg_package() {
  info "packaging $NAME"

  if ! fn_exists install; then
    if [[ -e Makefile ]]; then
      grep -q 'install:' Makefile &>/dev/null

      if [ $? -eq 0 ]; then
        $INSTALL
      fi
    fi
  else
    if [[ $SILENT = yes ]]; then
      install &>/dev/null
    else
      install
    fi
  fi
}

pkg_installs() {
  pkg

  if [[ $PKGTYPE = normal ]] || [[ $PKGTYPE = git ]]; then
    if pkg_exists $PKG; then
      die "package $PKG is already installed"
    fi

    for dep in "${deps[@]}"; do
      if ! pkg_exists $dep; then
        sh $NONO -i $dep
      fi
    done

    local installed=no

    if [[ -d $WORK ]]; then
      cd $WORK

      for file in "${files[@]}"; do
        [[ -d $file ]] || [[ -e $file ]] && installed=yes
      done

      cd $BASE
    fi

    if [[ $installed = yes ]]; then
      info "installed missing built package: $PKG"
      echo $PKG >> $PKGS
      return
    fi

    info "installing $NAME"
  fi

  if [[ $PKGTYPE = normal ]]; then
    if [[ ! -d $WORK ]] && [[ ! -e $FILE ]]; then
      pkg_download
    fi

    if [[ ! -e $FILE ]]; then
      die "failed to download pkg: $PKG"
    elif [[ ! -d $WORK ]]; then
      pkg_extract
    fi

    if [[ ! -d $WORK ]]; then
      die "failed to extract package: $PKG"
    elif [[ -d $FILES ]]; then
      yes | \cp -rf $FILES/* $WORK
    fi

    cd $WORK

    pkg_configure
    pkg_build
    pkg_package
  elif [[ $PKGTYPE = git ]]; then
    if [[ ! -d $WORK ]]; then
      pkg_download
    fi

    if [[ ! -d $WORK ]]; then
      die "failed to clone $NAME"
    else
      if [[ -d $FILES ]]; then
        yes | \cp -rf $FILES/* $WORK
      fi

      cd $WORK

      pkg_build
      pkg_configure
      pkg_package
    fi
  else
    if pkg_exists $PKG; then
      found=no

      for dep in ${deps[@]}; do
        if ! pkg_exists $dep; then
          found=yes
          sh $NONO -i $dep
        fi
      done

      if [[ $found = no ]]; then
        info "nothing to do"
      fi

      return
    else
      for dep in "${deps[@]}"; do
        sh $NONO -i $dep
        if ! pkg_exists $dep; then
          return
        fi
      done
    fi
  fi

  echo $PKG >> $PKGS

  if [[ $PKGTYPE != group ]]; then
    info "package $PKG installed successfully"
  fi
}

pkg_remove() {
  pkg_open

  if fn_exists remove; then
    if remove; then
      sed -i "/$PKG/d" $PKGS
    fi
  fi
}

####### up is old code #####################

############## package storage ################################

entry_exists() {
  [[ ! -e $PKGS ]] && \
    return 1

  return $(grep -q "$1" $PKGS)
}

add_entry() {
  [[ ! -e $PKGS ]] && \
    return 1

  echo "$1" >> $PKGS
  return 0
}

#

####### log ##########

die() {
  echo "$@"
  exit 1
}

####### utils ##########

read_setting() {
  line=$(grep "${1}=" $2)
  value=${line#*=}
  value=${value//(}
  value=${value//)}
  echo $value
}

array_contains() {
    local seeking=$1; shift
    local in=1
    for element; do
        if [[ $element == "$seeking" ]]; then
            in=0
            break
        fi
    done
    return $in
}

fn_exists() {
  if type $1 2>/dev/null | grep -q 'function'; then
    return 0
  fi
  return 1
}

########### preparation ##############

# needed when installing something
config() {
  [[ -z $ROOT ]] && \
    ROOT=$(dirname $PWD)

  [[ -d $ROOT/pkg ]] || \
    die "invalid root"

  [[ -z $INSTALL ]] && \
    INSTALL=$ROOT

  SRC=$ROOT/src
  PKGS=$ROOT/pkgs
}

# used for packages, not groups
read_recipe() {
  local pkg=$1

  local pkgdir=$ROOT/pkg/$pkg

  local small

  [[ -e $pkgdir ]] && \
    small=yes

  [[ -d $pkgdir ]] && \
    small=no

  [[ -z $small ]] && \
    echo "null" && return 1

  local pkgfile

  if [[ $small = yes ]]; then
    pkgfile=$pkgdir
  else
    pkgfile=$pkgdir/build
  fi

  echo $pkgfile
}

################### Group handling #################

# example:

# base:
# option=USERLAND
# options=(base-suckless base-busybox)

# set_option base busybox -> USERLAND=busybox
# get_option base -> USERLAND

# get_option_value base -> busybox
# get_choose: get_option_value with checks

# notes:
# default option is first
# only group (main) will be count as installed
# 'config' file can override options (USERLAND), else it will be asked, if timeout, default

#############################################

# package 'group' has alternatives
is_group() {
  local name=$1

  local file=$ROOT/pkg/$name

  if [[ ! -e $file ]]; then
    return 1
  fi

  declare local options="$(read_setting options $file)"

  if [[ -z $options ]]; then
    return 1
  fi

  return 0
}

# can a package be used for as alternative
is_option() {
  local pkg=$1

  local file=$(read_recipe $pkg)

  if [[ $file = null ]]; then
    return 1
  fi

  return $(is_group "$(read_setting group $file)")
}

option_set() {
  if [[ ! -z $(get_option_value $1) ]]; then
    return 0
  fi
  return 1
}

get_option_value() {
  local option=$(get_option $1)
  echo "${!option}"
}

get_option() {
  local name=$1

  local file=$ROOT/pkg/$name

  if [[ ! -e $file ]]; then
    echo "null"
  fi

  if is_group $name; then
    echo "$(read_setting option $file)"
    return
  fi

  echo "null"
}

set_option() {
  local option=$(get_option $1)
  local choose=$2

  if [[ -z $option ]] || [[ -z $choose ]]; then
     return 1
  fi

  eval "$option"="$choose"

  return 0
}

# get chosen package by using name in variable given by package
get_choose() {
  local name=$1

  if is_group $name; then
    declare local options="$(read_setting options $ROOT/pkg/$name)"

    local choose=$(get_option_value $name)

    # default
    if [[ -z $choose ]]; then
      temp=$options
      set -- $temp
      choose=$1
    fi

    if array_contains $choose ${options[@]}; then
      echo $choose
      return
    fi

    echo "null"
  fi
}

############# packages ##########

settings=(name ver src deps group files)

pkg_exists() {
  local pkg=$1

  local file=$(read_recipe $pkg)

  if [[ $file = null ]]; then
    return 1
  fi
  return 0
}

pkg_installed() {
  local pkg=$1

  if ! pkg_exists $pkg; then
    return 1
  fi

  if is_group $pkg; then
    declare local options="$(read_setting options $file)"

    for option in ${options[@]}; do
      if entry_exists $option; then
        return 0
      fi
    done
  else
    return $(entry_exists $pkg)
  fi

  return 1
}

install_pkg() {
  local pkgs=()

  for pkg in $@; do
    if ! array_contains $pkg ${pkgs[@]}; then
      pkgs+=($pkg)
    fi
  done

  config

  local list=()

  for pkg in ${pkgs[@]}; do
    local file=$(read_recipe $pkg)

    if [[ $file = null ]]; then
      echo "package $pkg doesnt exists"
      continue
    fi

    for dep in $(read_setting deps $file); do
      if ! array_contains $dep ${list[@]}; then
        list+=($dep)
      fi
    done

    list+=($pkg)
  done

  for pkg in ${list[@]}; do
    local file=$(read_recipe $pkg)

    if [[ $file = null ]]; then
      echo "dependency $pkg doesnt exist"
      #local error=yes
      continue
    fi

    if [[ $error = yes ]]; then
      echo "package $pkg error"
      continue
    fi

    pkg_install $pkg
  done
}

ask_options() {
  local pkg=$1
  return
  echo "choose options for: $pkg"
  echo "todo"
  # set_option $pkg base-suckless
}

pkg_install() {
  local pkg=$1

  if pkg_installed $pkg; then
    echo "package $pkg is already installed"
    return
  fi

  if is_group $pkg; then
    if ! option_set $pkg; then
      ask_options $pkg
    fi

    local choose=$(get_choose $pkg)

    if [[ $choose = null ]]; then
      echo "option is set wrong: $pkg"
      return
    fi

    if ! pkg_exists $choose; then
      echo "option $choose package doesnt exist: $pkg"
      return
    fi

    echo "installing option: $choose"
    pkg_install $choose
    return
  fi

  echo "installing: $pkg"

  local file=$(read_recipe $pkg)

  for setting in ${settings[@]}; do
    declare local $setting="$(read_setting $setting $file)"
  done

  if [[ ! -z $src ]]; then
    echo $src
  fi

  return # after install: TODO

  if is_group $group; then
    add_entry $group
  else
    add_entry $pkg
  fi
}

remove_pkg() {
  local pkgs=()

  for pkg in $@; do
    if ! array_contains $pkg ${pkgs[@]}; then
      pkgs+=($pkg)
    fi
  done

  config

  local list=()

  for pkg in ${pkgs[@]}; do
    echo $pkg
  done
}

help() {
  echo "todo"
}

run() {
  action=$1 && shift

  case $action in
  -i) install_pkg $@ ; ;;
  -r) remove_pkg $@ ; ;;
  *) help ; ;;
  esac
}

run $@